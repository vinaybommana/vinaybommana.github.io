* making .emacs to read your own customizations
   :PROPERTIES:
   :CUSTOM_ID: making-.emacs-to-read-your-own-customizations
   :END:

Add these following lines to your =.emacs= file this will load all the
=*.el= files in your =~/.emacs.d/lisp= directory.

{% highlight elisp %}

;; load custom files ;; from emacs stack exchange (defun load-directory
(dir) (let ((load-it (lambda (f) (load-file (concat
(file-name-as-directory dir) f))) )) (mapc load-it (directory-files dir
nil "\.el$")))) (load-directory "~/.emacs.d/lisp")

{% endhighlight %}

* conditionals
There are mainly four types of elisp conditionals.
 - if
 - which
 - unless
 - cond

*** if (Special Form)

#+BEGIN_QUOTE
  =if= chooses between the then-form and the else-forms based on the
  value of condition. If the evaluated condition is non-nil, then-form
  is evaluated and the result returned. Otherwise, the else-forms are
  evaluated in textual order, and the value of the last one is returned.
  (The else part of if is an example of an implicit progn.)
#+END_QUOTE

#+BEGIN_QUOTE
  =if= condition has the value nil, and no else-forms are given, if
  returns nil.
#+END_QUOTE

{% highlight elisp %} (if nil (print 'true) 'very-false)

{% endhighlight %} > This returns =very-false=.

{% highlight elisp %}

(if evil-mode (powerline-raw (powerline-evil-tag) evil-face) ) {%
endhighlight %}

*** cond (Special Form)
	=cond= chooses among an arbitrary number of alternatives. Each /clause/ in the =cond= must be a list.
    The car of this list is the /condition/; the remaining elements, if any, the =body-forms=. Thus, a clause
    looks like this:
#+BEGIN_SRC elisp
(condition body-forms...)
#+END_SRC

=cond= tries the clauses in textual order, by evaluating the /condition/ of each clause.
If the /condition/ is non-=nil=, the clause succeeds; then =cond= evaluates its /body-forms/,
and returns the value of the last of /body-forms/. Any remaining clauses are ignored.

#+BEGIN_SRC elisp
(condition)
#+END_SRC

Then, if /condition/ is non-=nil= when tested, the =cond= form returns the value of /condition/.

If every /condition/ evaluates to =nil=, so that every clause fails,
=cond= returns =nil=.

The following example has four clauses, which test for the cases where the value of =x= is a number,
string, buffer and symbol, respectively:

#+BEGIN_SRC elisp
(cond ((numberp x) x)
      ((stringp x) x)
      ((bufferp x)
       (setq temporary-hack x); multiple body-forms
       (buffer-name x))       ; in one clause
       ((symbolp x) (symbol-value x)))

#+END_SRC

Often we want to execute the last clause whenever none of the previous clauses was successful.
To do this, we use =t= as the condition of the last clause, like this: =(t body-forms)=.
The form =t= evaluates to =t=, which is never =nil=, so this clause never fails, provided the =cond= gets to it at all.
For example:

#+BEGIN_SRC elisp
(setq a 5)
(cond ((eq a 'hack) 'foo)
      (t "default"))
#+END_SRC
output is ="default"=
This cond expression returns =foo= if the value of =a= is hack, and returns the string ="default"= otherwise.

Any conditional construct can be expressed with =cond= or with =if=.
Therefore, the choice between them is a matter of style. 
For example:

#+BEGIN_SRC elisp
(if a b c)
==
(cond (a b) (t c))
#+END_SRC

* lists
   :PROPERTIES:
   :CUSTOM_ID: lists
   :END:

* functions
   :PROPERTIES:
   :CUSTOM_ID: functions
   :END:
